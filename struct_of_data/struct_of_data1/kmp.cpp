//
// Created by 21050 on 2023/5/5.
//
/*
 * 先从暴力入手，再去优化
 * kmp算法：假设有一个字符串：S[N],P[M]
 * 在S中去匹配P字符串，P为模板串，S为待匹配的字符串
 * S: ************************************()********$()**************************
 * P(前):                    *************()********$(i)******(起始点为1)
 * P(后):                                 ()********$(j)*************
 * 对P字符串进行预处理：从每个点开始的后缀和前缀相匹配的位数的最大值，最大值越大，则每次移动的距离越近
 * 使用next[]数组进行存储，next[i]表示的是，以i结束的后缀和从1开始的前缀相等，且最长
 * 例如：next[i] = j, 即有： p[1, j] = p[i - j + 1, i]
 * 具体应用场景：
 * S: **********************************$(i)*************** 在i处不一样
 * p:                          *********$(j + 1)*********************** 匹配了前j个字符
 *
 * p字符串的next[i]具体指的就是p字符串的前i个字符，这前i个字符构成的字符串，前缀和后缀相等的最大值即为next[i](前next[i]个字符和后next[i]个字符想等);
 */
#include <iostream>

using namespace std;

const int N = 1e4 + 10, M = 1e5 + 10;
int n, m;
int p[N], S[M];
int ne[M];

int main(){
    scanf("%d%d", &n, &m);
    //求ne[i]的过程：
    for(int i = 2, j = 0;i <= n;i++){//ne[1] = 0,如果匹配第一个字母失败了，只能从第0个开始匹配了
        while(j && p[i] != p[j + 1]) j = ne[j];//前j个均匹配，但j + 1个未成，回退至next[j]处
        if(p[i] == p[j + 1]) j++;
        ne[i] = j;//表示前j个字符匹配
    }
    for(int i = 1, j = 0;i <= m;i++){
        while(j && S[i] != p[j + 1]) j = ne[j];//j跑到下一个能匹配的位置，保证前j个始终匹配, 在这个过程中，j指针在往回退，但本质上就是p字符串往后走去匹配S
        if(S[i] == p[j + 1]) j++;//前j + 1个已经匹配，故更新一下j
        if(j == n){/*匹配成功*/}
        //接着判断下一位是否匹配
    }

    return 0;
}